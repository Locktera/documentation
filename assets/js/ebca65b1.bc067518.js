"use strict";(self.webpackChunklocktera_api_documentation=self.webpackChunklocktera_api_documentation||[]).push([[914],{6930:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Use Cases/Encode-Folder","title":"Encode A Folder","description":"This example uses the Locktera API to encode all contents from a folder.","source":"@site/docs/Use Cases/Encode-Folder.md","sourceDirName":"Use Cases","slug":"/Use Cases/Encode-Folder","permalink":"/documentation/docs/Use Cases/Encode-Folder","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"apiSidebar","previous":{"title":"Writing DRM Rules","permalink":"/documentation/docs/Use Cases/DRM-Rules-Write"}}');var o=n(4848),s=n(8453);const r={},a="Encode A Folder",c={},l=[{value:"Imports",id:"imports",level:2},{value:"Encode operations",id:"encode-operations",level:2},{value:"construct_manifest()",id:"construct_manifest",level:3},{value:"encode_container()",id:"encode_container",level:3},{value:"Bringing it all together",id:"bringing-it-all-together",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"encode-a-folder",children:"Encode A Folder"})}),"\n",(0,o.jsx)(t.p,{children:"This example uses the Locktera API to encode all contents from a folder."}),"\n",(0,o.jsxs)(t.p,{children:["To customize the content to be encoded by the example, look at and modify the contents of the ",(0,o.jsx)(t.code,{children:"input"})," folder."]}),"\n",(0,o.jsx)(t.p,{children:"A walkthrough of the code follows."}),"\n",(0,o.jsx)(t.h2,{id:"imports",children:"Imports"}),"\n",(0,o.jsx)(t.p,{children:"First we'll import the libraries we'll need."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"import * as glob from 'glob'; // Used to find content files to encode\r\nimport mime from 'mime'; // Used to determine content file types\r\nimport * as fs from 'node:fs/promises'; // Used to read the manifest\r\nimport * as path from 'path'; // Used to get path basenames\n"})}),"\n",(0,o.jsx)(t.p,{children:"We will also need to import libraries specific to the task at hand - creating a Locktera container manifest and interacting with the Locktera API."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"import { type Manifest } from '../Manifest.ts'; // The definition of the Locktera container manifest\r\nimport { ORG_ID, fetch, verify_identity } from '../fetch.ts'; // Our org ID, authenticated fetch function, and sanity check function\n"})}),"\n",(0,o.jsx)(t.h2,{id:"encode-operations",children:"Encode operations"}),"\n",(0,o.jsx)(t.p,{children:"We will use the encode endpoint of the Locktera API, but first we need to describe our container."}),"\n",(0,o.jsx)(t.h3,{id:"construct_manifest",children:"construct_manifest()"}),"\n",(0,o.jsxs)(t.p,{children:["This function constructs a Locktera container manifest from the contents of the ",(0,o.jsx)(t.code,{children:"input"})," folder. The ",(0,o.jsx)(t.code,{children:"manifest.json"})," file forms the basis of the manifest, mostly consisting of any DRM rules. Then, we ",(0,o.jsx)(t.code,{children:"glob"})," other files from the folder to fill out the ",(0,o.jsx)(t.code,{children:"files"})," section of the manifest with their metadata."]}),"\n",(0,o.jsxs)(t.p,{children:["See the ",(0,o.jsx)(t.code,{children:"Manifest.ts"})," file in the ",(0,o.jsx)(t.code,{children:"typescript"})," directory for the type definition."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"async function construct_manifest () {\r\n\t// Read the manifest from input/manifest.json\r\n\tconst manifest: Manifest = JSON.parse(await fs.readFile('./input/manifest.json', 'utf-8'));\n"})}),"\n",(0,o.jsx)(t.p,{children:"We could actually stop here and just return this basic manifest. As long as we provide a basic manifest and a set of files to the API, we don't need to include any information about those files - the API will discover each file's name, content type, and size from the API request body."}),"\n",(0,o.jsx)(t.p,{children:"For instructional purposes, however, we will go ahead and fill in the basic information about each file we want to include."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"\tmanifest.files = {};\r\n\r\n\t// Add content files to the manifest\r\n\tfor await (const file of glob.globIterate('./input/*')) {\r\n\t\t// Strip the directory name\r\n\t\tconst basename = path.basename(file);\r\n\r\n\t\t// Don't include the manifest itself in the container!\r\n\t\tif (basename === 'manifest.json') continue;\n"})}),"\n",(0,o.jsx)(t.p,{children:"Since this is a basic example, we will just include the content type for each file. The content type must be provided either here in the manifest, or in the request body. If it is in both locations, the manifest will override the request body."}),"\n",(0,o.jsx)(t.p,{children:"For more advanced use cases, we can include metadata like page counts or media durations, as well as controlling what files are viewed versus what files are downloaded. These advanced features will be demonstrated in a later example."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"\t\t// Create an informational record for each content file, indexed by name\r\n\t\tmanifest.files[basename] = {\r\n\t\t\t// Determine the file type based on the file extension\r\n\t\t\ttype: mime.getType(basename) || 'application/octet-stream',\r\n\t\t};\r\n\t}\r\n\r\n\tconsole.log('Encoding manifest:', manifest);\r\n\treturn manifest;\r\n}\n"})}),"\n",(0,o.jsx)(t.h3,{id:"encode_container",children:"encode_container()"}),"\n",(0,o.jsx)(t.p,{children:"This function takes our previously-constructed manifest and sends it and the content files to the Locktera API for encryption. This is probably the most complex function of the entire API, both in terms of its functionality and in terms of how the request must be constructed."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"async function encode_container (manifest: Manifest) {\r\n\t// The data will be sent to the API as multipart form data, so we will use the FormData class to build the body\r\n\tconst body = new FormData();\r\n\r\n\t// The manifest must be sent as the value for the `manifest` key\r\n\tbody.append('manifest', new Blob([JSON.stringify(manifest)], { type: 'application/json' }));\r\n\r\n\tfor (const [name, file] of Object.entries(manifest.files!)) {\r\n\t\t// Since a Node.js `Blob` can only be constructed from strings or binary buffers, we must read the entire content file into a binary buffer\r\n\t\tconst data = await fs.readFile(`./input/${name}`);\r\n\r\n\t\t// Each content file must be appended to the value of the `files` key\r\n\t\tbody.append('files', new Blob([data], { type: file.type }), name);\n"})}),"\n",(0,o.jsxs)(t.p,{children:["As mentioned in ",(0,o.jsx)(t.code,{children:"construct_manifest()"}),", the content type of each file must be specified in either the manifest or the request body. We are also including them here to show how it is done."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"\t}\r\n\r\n\t// Encode the file!\r\n\tconst encoded_manifest = await fetch(`/orgs/${ORG_ID}/containers/encode`, {\r\n\t\tmethod: 'POST',\r\n\t\tbody,\r\n\t});\r\n\r\n\tconsole.log('Successfully encoded container:', encoded_manifest.container.uuid);\r\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"bringing-it-all-together",children:"Bringing it all together"}),"\n",(0,o.jsx)(t.p,{children:"We will finally call the 3 API operations in sequence to encode our container."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"await verify_identity();\r\nconst manifest = await construct_manifest();\r\nawait encode_container(manifest);\n"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(6540);const o={},s=i.createContext(o);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);